<html>
<head>
<title>WebGL</title>

<script type="text/javascript" src="http://webkit.org/blog-files/webgl/resources/J3DI.js"></script>
<script type="text/javascript" src="http://webkit.org/blog-files/webgl/resources/J3DIMath.js"></script>
<script type="text/javascript" src="http://code.jquery.com/jquery-1.4.2.min.js"></script>

</head>
<body>
<canvas id="viewport" width="1024" height="768"></canvas>

<script id="vertex_shader" type="x-shader/x-vertex">

#define M_PI 3.14159265358979323846
#define M_1_PI 0.31830988618379067154
#define M_2_PI 0.63661977236758134308

#define RBSN_SCALE 0.5072
uniform vec2 robinsonParallels[19];

uniform mat4 modelViewProjMatrix;
attribute vec4 vPosition;

void main(void) {
	float lam = radians(vPosition.x);
	float phi = radians(vPosition.y);
	
	float pos = abs(phi * M_2_PI) * 18.0;
	int idx1 = int(floor(pos));
	int idx2 = int(ceil(pos));
	vec2 robinsonRow = mix(robinsonParallels[idx1], robinsonParallels[idx2], fract(pos));
	gl_Position.x = robinsonRow.x * lam * M_1_PI;
	gl_Position.y = sign(phi) * robinsonRow.y * RBSN_SCALE;
	gl_Position.z = 0.0;
	gl_Position.w = 1.0;
    gl_Position = modelViewProjMatrix * gl_Position;
	//gl_PointSize = 1.0;
}

</script>

<script id="fragment_shader" type="x-shader/x-fragment">

void main(void) {
    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
}

</script>


<script type="text/javascript">
//var gl, canvas;
var robinsonStuff, viewTransform, vPositionIdx, host, dataType;

if (!Float32Array.prototype.set) {
	// FF4 doesn't conform to Khronos typed array draft
	// NOTE: this doesn't either (e.g. it fails if array is a typed array, etc.)
	Float32Array.prototype.set = function (array, offset) {
		offset = offset || 0;
		array.forEach(function (val, i) {
			this[i+offset] = val;
		}, this);
	}
	//Uint8Array.prototype.set = Float32Array.prototype.set;
}

canvas = document.getElementById('viewport');
gl = canvas.getContext('experimental-webgl');
gl.console = ("console" in window) ? window.console : { log: function() { } };
gl.console.logErrors = function () {
	var err, NAMES = {1280:'INVALID_ENUM', 1281:'INVALID_VALUE', 1282:'INVALID_OPERATION', 1283:'STACK_OVERFLOW', 1284:'STACK_UNDERFLOW', 1285:'OUT_OF_MEMORY'};
	while (err = gl.getError()) {
		gl.console.log(NAMES[err]);
	}
};

gl.program = gl.createProgram();
gl.attachShader(gl.program, loadShader(gl, 'vertex_shader'));
gl.attachShader(gl.program, loadShader(gl, 'fragment_shader'));
gl.linkProgram(gl.program);
gl.useProgram(gl.program);

// robinsonParallels
robinsonStuff = {};
robinsonStuff.plen = [1.0000, 0.9986, 0.9954, 0.9900, 0.9822, 0.9730, 0.9600, 0.9427, 0.9216, 0.8962, 0.8679, 0.8350, 0.7986, 0.7597, 0.7186, 0.6732, 0.6213, 0.5722, 0.5322];
robinsonStuff.pdfe = [0.0000, 0.0620, 0.1240, 0.1860, 0.2480, 0.3100, 0.3720, 0.4340, 0.4958, 0.5571, 0.6176, 0.6769, 0.7346, 0.7903, 0.8435, 0.8936, 0.9394, 0.9761, 1.0000];
robinsonStuff.numSamples = robinsonStuff.plen.length;
robinsonStuff.textureData = new Float32Array(2 * robinsonStuff.numSamples);
robinsonStuff.plen.forEach(function (robinsonStuff_plen_i_, i) {
	robinsonStuff.textureData.set([robinsonStuff_plen_i_, robinsonStuff.pdfe[i]], 2 * i);
});
gl.uniform2fv(gl.getUniformLocation(gl.program, 'robinsonParallels'), robinsonStuff.textureData);

// modelViewProjMatrix
viewTransform = new J3DIMatrix4();
viewTransform.scale(1.0, canvas.width / canvas.height);
viewTransform.scale(1);
//viewTransform.translate(-0.1, -0.85);
gl.uniformMatrix4fv(gl.getUniformLocation(gl.program, 'modelViewProjMatrix'), false, viewTransform.getAsFloat32Array());

// vPosition
vPositionIdx = gl.getAttribLocation(gl.program, 'vPosition');
gl.enableVertexAttribArray(vPositionIdx);
gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());

gl.clearColor(0,0,0,1);
gl.clearDepth(1);
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

function drawShape(vertexArray) {
	var vertices;
	
	// unzip the vertexArray
	vertices = new Float32Array(vertexArray.length * 2);
	vertexArray.forEach(function (pair, i) {
		//if (i % 5) return;
		vertices.set(pair, 2*i);
	});
	
	gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STREAM_DRAW);
	gl.vertexAttribPointer(vPositionIdx, 2, gl.FLOAT, false, 0, 0);
	gl.drawArrays(gl.LINE_LOOP, 0, vertices.length / 2);
}

if (window.location.host) {
	host = "http://natevw.couchone.com/countries/";
	dataType = 'jsonp';
} else {
	host = "http://localhost:5984/countries/";
	dataType = 'json';	// use 'jsonp' for FF4/Chrome locally
}
$.get(host + '_all_docs', function (result) {
	var countryList = result.rows.filter(function (row) { return row.id[0] != '_'; }).map(function (row) { return row.id; });
	countryList.forEach(function (docId) {
		$.get(host + docId, function (doc) {
			var shapes;
			if (doc.geometry.type === 'MultiPolygon') {
				shapes = doc.geometry.coordinates;
			} else if (doc.geometry.type === 'Polygon') {
				shapes = [doc.geometry.coordinates];
			}
			shapes.forEach(function (polygon) {
				drawShape(polygon[0]);
			});
		}, dataType);
	});
}, dataType);

</script>

</body>
</html>