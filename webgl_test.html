<html>
<head>
<title>WebGL</title>

<script type="text/javascript" src="http://webkit.org/blog-files/webgl/resources/J3DI.js"></script>
<script type="text/javascript" src="http://webkit.org/blog-files/webgl/resources/J3DIMath.js"></script>
<script type="text/javascript" src="http://code.jquery.com/jquery-1.4.2.min.js"></script>

</head>
<body>
<canvas id="viewport" width="1024" height="768" />

<script id="vertex_shader" type="x-shader/x-vertex">

#define M_PI 3.14159265358979323846
#define M_1_PI 0.31830988618379067154
#define M_2_PI 0.63661977236758134308
#define RBSN_SCALE 0.5072

uniform sampler2D robinsonTable;

uniform mat4 modelViewProjMatrix;
attribute vec4 vPosition;

void main(void) {
	float lam = radians(vPosition.x);
	float phi = radians(vPosition.y);
	
	vec4 robinsonRow = texture2D(robinsonTable, vec2(abs(phi * M_2_PI), 0.5));
	// NOTE: this doesn't work any better, because each channel is sampled independently
	float plen = (255.0 * 256.0 * robinsonRow.r + 255.0 * robinsonRow.g) / 65535.0;
	float pdfe = (255.0 * 256.0 * robinsonRow.b + 255.0 * robinsonRow.a) / 65535.0;
	gl_Position.x = 0.5 * plen * lam * M_2_PI;
	gl_Position.y = sign(phi) * pdfe * RBSN_SCALE;
	gl_Position.z = 0.0;
	gl_Position.w = 1.0;
    gl_Position = modelViewProjMatrix * gl_Position;
	//gl_PointSize = 1.0;
}

</script>

<script id="fragment_shader" type="x-shader/x-fragment">

void main(void) {
    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
}

</script>


<script type="text/javascript">
//var gl, canvas;
var robinsonStuff, viewTransform, vPositionIdx, dataType;

if (!Float32Array.prototype.set) {
	// FF4 doesn't conform to Khronos typed array draft
	// NOTE: this doesn't either (e.g. it fails if array is a typed array, etc.)
	Float32Array.prototype.set = function (array, offset) {
		offset = offset || 0;
		array.forEach(function (val, i) {
			this[i+offset] = val;
		}, this);
	}
	Uint8Array.prototype.set = Float32Array.prototype.set;
}

canvas = document.getElementById('viewport');
gl = canvas.getContext('experimental-webgl');
gl.console = ("console" in window) ? window.console : { log: function() { } };
gl.console.logErrors = function () {
	var err, NAMES = {1280:'INVALID_ENUM', 1281:'INVALID_VALUE', 1282:'INVALID_OPERATION', 1283:'STACK_OVERFLOW', 1284:'STACK_UNDERFLOW', 1285:'OUT_OF_MEMORY'};
	while (err = gl.getError()) {
		gl.console.log(NAMES[err]);
	}
};

gl.program = gl.createProgram();
gl.attachShader(gl.program, loadShader(gl, 'vertex_shader'));
gl.attachShader(gl.program, loadShader(gl, 'fragment_shader'));
gl.linkProgram(gl.program);
gl.useProgram(gl.program);

// robinsonTable
gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, gl.createTexture());
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
robinsonStuff = {};
robinsonStuff.plen = [1.0000, 0.9986, 0.9954, 0.9900, 0.9822, 0.9730, 0.9600, 0.9427, 0.9216, 0.8962, 0.8679, 0.8350, 0.7986, 0.7597, 0.7186, 0.6732, 0.6213, 0.5722, 0.5322];
robinsonStuff.pdfe = [0.0000, 0.0620, 0.1240, 0.1860, 0.2480, 0.3100, 0.3720, 0.4340, 0.4958, 0.5571, 0.6176, 0.6769, 0.7346, 0.7903, 0.8435, 0.8936, 0.9394, 0.9761, 1.0000];
robinsonStuff.numSamples = robinsonStuff.plen.length;
robinsonStuff.textureData = new Uint8Array(4 * robinsonStuff.numSamples);
robinsonStuff.plen.forEach(function (robinsonStuff_plen_i_, i) {
	var intPLEN, intPDFE;
	intPLEN = 65535 * robinsonStuff_plen_i_;
	intPDFE = 65535 * robinsonStuff.pdfe[i];
	robinsonStuff.textureData.set([intPLEN >>> 8, intPLEN, intPDFE >>> 8, intPDFE], 4 * i);
});
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, robinsonStuff.numSamples, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, robinsonStuff.textureData);
gl.uniform1i(gl.getUniformLocation(gl.program, 'robinsonTable'), 0);

// modelViewProjMatrix
viewTransform = new J3DIMatrix4();
viewTransform.scale(1.0, canvas.width / canvas.height);
viewTransform.scale(1/2);
gl.uniformMatrix4fv(gl.getUniformLocation(gl.program, 'modelViewProjMatrix'), false, viewTransform.getAsFloat32Array());

// vPosition
vPositionIdx = gl.getAttribLocation(gl.program, 'vPosition');
gl.enableVertexAttribArray(vPositionIdx);
gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());

gl.clearColor(0,0,0,1);
gl.clearDepth(1);
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

function drawShape(vertexArray) {
	var vertices;
	
	// unzip the vertexArray
	vertices = new Float32Array(vertexArray.length * 2);
	vertexArray.forEach(function (pair, i) {
		//if (i % 5) return;
		vertices.set(pair, 2*i);
	});
	
	gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STREAM_DRAW);
	gl.vertexAttribPointer(vPositionIdx, 2, gl.FLOAT, false, 0, 0);
	gl.drawArrays(gl.POINTS, 0, vertices.length / 2);
}

dataType = 'json';	// use 'jsonp' for FF4
$.get("http://localhost:5984/countries/_all_docs", function (result) {
	var countryList = result.rows.filter(function (row) { return row.id[0] != '_'; }).map(function (row) { return row.id; });
	countryList.forEach(function (docId) {
		$.get("http://localhost:5984/countries/" + docId, function (doc) {
			var shapes;
			if (doc.geometry.type === 'MultiPolygon') {
				shapes = doc.geometry.coordinates;
			} else if (doc.geometry.type === 'Polygon') {
				shapes = [doc.geometry.coordinates];
			}
			shapes.forEach(function (polygon) {
				drawShape(polygon[0]);
			});
		}, dataType);
	});
}, dataType);

</script>

</body>
</html>