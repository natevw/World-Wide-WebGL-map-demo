<html>
<head>
<title>WebGL</title>

<script type="text/javascript" src="http://webkit.org/blog-files/webgl/resources/J3DI.js"></script>
<script type="text/javascript" src="http://webkit.org/blog-files/webgl/resources/J3DIMath.js"></script>
<script type="text/javascript" src="http://code.jquery.com/jquery-1.4.2.min.js"></script>

</head>
<body style="background: cornsilk">
<canvas id="viewport" width="2048" height="1536" style="width: 1024; height: 768"></canvas>
<div id="frames"></div>

<script id="robinson_vertex_shader" type="x-shader/x-vertex">

#define M_PI 3.14159265358979323846
#define M_1_PI 0.31830988618379067154
#define M_2_PI 0.63661977236758134308

#define RBSN_SCALE 0.5072
uniform vec2 robinsonParallels[19];

uniform mat4 modelViewProjMatrix;
uniform float blend;

attribute vec2 vPosition;
varying vec2 textureCoord;

void main(void) {
    vec2 coord = radians(vPosition);
    textureCoord = vPosition / vec2(360.0, -180.0) + 0.5;
	
	float pos = abs(coord.y * M_2_PI) * 18.0;
	int idx1 = int(floor(pos));
	int idx2 = int(ceil(pos));
	vec2 robinsonRow = mix(robinsonParallels[idx1], robinsonParallels[idx2], fract(pos));
    
    vec2 robinsonResult = vec2(robinsonRow.x * coord.x * M_1_PI,
                               sign(coord.y) * robinsonRow.y * RBSN_SCALE);
    vec2 mercatorResult = vec2(coord.x, log(tan(M_PI/4.0 + coord.y/2.0)));
    mercatorResult.y = clamp(mercatorResult.y, -2.5, 2.5);
    
    gl_Position.xy = mix(robinsonResult, mercatorResult, blend);
	gl_Position.z = 0.0;
	gl_Position.w = 1.0;
    gl_Position = modelViewProjMatrix * gl_Position;
}

</script>


<script id="color_fragment_shader" type="x-shader/x-fragment">

uniform mediump vec4 color;

void main(void) {
    gl_FragColor = color;
}

</script>


<script id="texture_fragment_shader" type="x-shader/x-fragment">

uniform sampler2D texture;
varying highp vec2 textureCoord;

void main(void) {
    gl_FragColor = texture2D(texture, textureCoord);
}

</script>



<script type="text/javascript">
//var gl, canvas;
var viewTransform, vPositionIdx, texture, polygons, host, dataType;

if (!Float32Array.prototype.set) {
	// FF4 doesn't conform to Khronos typed array draft
	// NOTE: this doesn't either (e.g. it fails if array is a typed array, etc.)
	Float32Array.prototype.set = function (array, offset) {
		offset = offset || 0;
		array.forEach(function (val, i) {
			this[i+offset] = val;
		}, this);
	}
	//Uint8Array.prototype.set = Float32Array.prototype.set;
}

canvas = document.getElementById('viewport');
gl = canvas.getContext('experimental-webgl');
gl.console = ("console" in window) ? window.console : { log: function() { } };
gl.e = gl.console.logErrors = function () {
    gl.flush();
    gl.finish();
	var err, NAMES = {1280:'INVALID_ENUM', 1281:'INVALID_VALUE', 1282:'INVALID_OPERATION', 1283:'STACK_OVERFLOW', 1284:'STACK_UNDERFLOW', 1285:'OUT_OF_MEMORY'};
	while (err = gl.getError()) {
		gl.console.log(NAMES[err]);
	}
    console.log("done logging errors");
};

gl.shaders = {};
gl.shaders.robinsonVertex = loadShader(gl, 'robinson_vertex_shader');
gl.shaders.colorFragment = loadShader(gl, 'color_fragment_shader');
gl.shaders.textureFragment = loadShader(gl, 'texture_fragment_shader');

gl.rasterProgram = gl.createProgram();
gl.attachShader(gl.rasterProgram, gl.shaders.robinsonVertex);
gl.attachShader(gl.rasterProgram, gl.shaders.textureFragment);
gl.linkProgram(gl.rasterProgram);
setupProgram(gl.rasterProgram);

gl.vectorProgram = gl.createProgram();
gl.attachShader(gl.vectorProgram, gl.shaders.robinsonVertex);
gl.attachShader(gl.vectorProgram, gl.shaders.colorFragment);
gl.linkProgram(gl.vectorProgram);
setupProgram(gl.vectorProgram);

function setupProgram(program) {
    var robinsonStuff;
    
    gl.useProgram(program);
    
    // robinsonParallels
    robinsonStuff = {};
    robinsonStuff.plen = [1.0000, 0.9986, 0.9954, 0.9900, 0.9822, 0.9730, 0.9600, 0.9427, 0.9216, 0.8962, 0.8679, 0.8350, 0.7986, 0.7597, 0.7186, 0.6732, 0.6213, 0.5722, 0.5322];
    robinsonStuff.pdfe = [0.0000, 0.0620, 0.1240, 0.1860, 0.2480, 0.3100, 0.3720, 0.4340, 0.4958, 0.5571, 0.6176, 0.6769, 0.7346, 0.7903, 0.8435, 0.8936, 0.9394, 0.9761, 1.0000];
    robinsonStuff.numSamples = robinsonStuff.plen.length;
    robinsonStuff.textureData = new Float32Array(2 * robinsonStuff.numSamples);
    robinsonStuff.plen.forEach(function (robinsonStuff_plen_i_, i) {
                               robinsonStuff.textureData.set([robinsonStuff_plen_i_, robinsonStuff.pdfe[i]], 2 * i);
                               });
    gl.uniform2fv(gl.getUniformLocation(program, 'robinsonParallels'), robinsonStuff.textureData);
    
    if (program === gl.rasterProgram) {
        // texture
        gl.uniform1i(gl.getUniformLocation(gl.rasterProgram, "texture"), 0);
    } else if (program === gl.vectorProgram) {
        // color
        gl.uniform4f(gl.getUniformLocation(gl.vectorProgram, "color"), 1.0, 1.0, 0.0, 0.1);
    }
    
    // vPosition
    vPositionIdx = gl.getAttribLocation(program, 'vPosition');
    gl.enableVertexAttribArray(vPositionIdx);
}

function switchToProgram(program, scale, blend) {
    gl.useProgram(program);
    
    // modelViewProjMatrix
    viewTransform = new J3DIMatrix4();
    viewTransform.scale(1.0, canvas.width / canvas.height);
    viewTransform.scale(scale);
    gl.uniformMatrix4fv(gl.getUniformLocation(program, 'modelViewProjMatrix'), false, viewTransform.getAsFloat32Array());
    
    // blend
    gl.uniform1f(gl.getUniformLocation(program, 'blend'), blend);
}


// setup raster background
texture = gl.createTexture();
texture.strips = [];
texture.image = new Image();
texture.image.onload = function () {
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    
    
    var vertices, b, x, xIdx, y, yIdx, vbo;
    b = {
        startX: -180, stepX: 5, countX: 72,
        startY: -90, stepY: 5, countY: 37
    };
    for (x = b.startX, xIdx = 0; xIdx < b.countX; xIdx += 1, x += b.stepX) {
        vertices = new Float32Array(4 * b.countY);
        for (y = b.startY, yIdx = 0; yIdx < b.countY; yIdx += 1, y += b.stepY) {
            vertices.set([x + b.stepX, y, x, y], 4 * yIdx);
        }
        
        vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        texture.strips.push({buffer: vbo, vertexCount: vertices.length / 2});
    }
};
texture.image.src = "HYP_50M_SR_W.jpg";


// setup vector overlay
polygons = [];
if (window.location.host) {
    host = "http://natevw.couchone.com/countries/";
    dataType = 'jsonp';
} else {
    host = "http://localhost:5984/countries/";
    dataType = 'jsonp';	// use 'jsonp' for FF4/Chrome locally
}
$.get(host + '_all_docs', function (result) {
    var countryList = result.rows.filter(function (row) { return row.id[0] != '_'; }).map(function (row) { return row.id; });
    countryList.forEach(function (docId) {
        $.get(host + docId, function (doc) {
            var shapes;
            if (doc.geometry.type === 'MultiPolygon') {
                shapes = doc.geometry.coordinates;
            } else if (doc.geometry.type === 'Polygon') {
                shapes = [doc.geometry.coordinates];
            }
            shapes.forEach(function (polygon) {
                var sourceArray, vertices, vbo;
                
                // unzip the sourceArray
                sourceArray = polygon[0];
                vertices = new Float32Array(sourceArray.length * 2);
                sourceArray.forEach(function (pair, i) {
                    //if (i % 5) return;
                    vertices.set(pair, 2*i);
                });
                
                // copy to buffer
                vbo = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                polygons.push({buffer: vbo, vertexCount: vertices.length / 2});
            });
        }, dataType);
    });
}, dataType);


function draw(scale, blend) {
    gl.clearColor(0,0,0,0);
    gl.clearDepth(1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    
    switchToProgram(gl.rasterProgram, scale, blend);
    
    texture.strips.forEach(function (strip) {
       gl.bindBuffer(gl.ARRAY_BUFFER, strip.buffer);
       gl.vertexAttribPointer(vPositionIdx, 2, gl.FLOAT, false, 0, 0);
       gl.drawArrays(gl.TRIANGLE_STRIP, 0, strip.vertexCount);
    });
    
    
    switchToProgram(gl.vectorProgram, scale, blend);
    
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.lineWidth(2);
    
    polygons.forEach(function (polygon) {
        gl.bindBuffer(gl.ARRAY_BUFFER, polygon.buffer);
        gl.vertexAttribPointer(vPositionIdx, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.LINE_LOOP, 0, polygon.vertexCount);
    });
}


fps = new Framerate('frames');

state = 0.0;
timer = setInterval(function () {
    var blend, scale;
    
    blend = 1 - Math.abs(state-1);
    scale = 0.5 - 0.25 * blend;
    draw(scale, blend);
    gl.flush();
    fps.snapshot();
    
    state = (state + 0.01) % 2.0;
}, 10);

</script>

</body>
</html>